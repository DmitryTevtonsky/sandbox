{"version":3,"sources":["components/clustering/utils.js","components/clustering/k-means/index.js","components/clustering/k-means/kmeans.js","components/clustering/dbscan/index.js","components/clustering/dbscan/utils.js","components/clustering/index.js","App.js","index.js"],"names":["generateClusterColors","size","colors","i","push","faker","internet","color","KMeansComponent","data","canvas","useRef","useState","setPointsCount","centersCount","setCentersCount","clustersCount","setClustersCount","isShowLengths","setIsShowLengths","isWorking","setIsWorking","kmeansRun","context","clearRect","width","height","clusterColors","kmeans","KMeans","k","fullLengths","Array","from","length","on","self","means","assignments","extents","ranges","point","fillStyle","fillRect","meanIndex","mean","globalAlpha","save","beginPath","x1","min","y1","x2","y2","moveTo","lineTo","strokeStyle","stroke","restore","translate","arc","Math","PI","closePath","fill","draw","console","log","iterations","isShowSubLength","round","sqrt","textAlign","textBaseline","font","fillText","x","y","defLength","reduce","sum","curr","shadowColor","shadowOffsetX","shadowOffsetY","shadowBlur","calculateLength","run","delay","useLayoutEffect","current","getContext","className","ref","id","placeholder","onChange","e","target","value","allowClear","checked","loading","onClick","type","distance","a","b","pow","DbscanComponent","maxX","maxY","labels","dbscan","uniqLabels","Set","TabPane","generateData","pointsCount","rangeX","rangeY","offset","min_x","max_x","min_y","max_y","num","option","rand_pts","name","scope","err","random","lx","ly","errx","erry","r","seeds","outlier","rx","ry","abs","generateRandomPoints","map","Object","values","Xxes","Yxes","forEach","apply","max","dataExtentRanges","Clustering","generatedData","useEffect","defaultActiveKey","tab","key","App","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.6a10fa7f.chunk.js","sourcesContent":["/* eslint-disable camelcase */\nimport faker from 'faker';\n\nexport function random(start, end) {\n  const dif = end - start;\n  return Math.random() * dif + start + 1;\n}\n\nexport function generateSampleData(points) {\n  const data = [];\n  // Generate random data\n  for (let i = 0; i < points; i++) {\n    data.push([random(0, 10), random(0, 10)]);\n  }\n  return data;\n}\n\nexport function generateClusterColors(size) {\n  const colors = [];\n  // Generate point color for each cluster.\n  for (let i = 0; i < size; i++) {\n    colors.push(faker.internet.color());\n  }\n  return colors;\n}\n\nexport function generateRandomPoints(min_x, max_x, min_y, max_y, num, option) {\n  const rand_pts = [];\n  switch (option.name) {\n    case 'linear': {\n      const { scope, err } = option;\n\n      for (var i = 0; i < num; i++) {\n        if (i > num * 0.9) {\n          rand_pts[i] = {\n            x: Math.random() * (max_x - min_x) + min_x,\n            y: Math.random() * (max_y - min_y) + min_y\n          };\n        } else {\n          const lx = Math.random() * (max_x - min_x) + min_x;\n          const ly = lx * scope;\n          var errx = Math.random() * err - err / 2;\n          var erry = Math.random() * err - err / 2;\n          rand_pts[i] = {\n            x: lx + errx,\n            y: ly + erry\n          };\n        }\n      }\n      break;\n    }\n    case 'circular': {\n      const r = [];\n      const seeds = [];\n      seeds.length = option.k;\n      r.length = option.k;\n      const { k } = option;\n      for (var i = 0; i < option.k; i++) {\n        seeds[i] = {\n          x: Math.random() * (max_x - min_x) + min_x,\n          y: Math.random() * (max_y - min_y) + min_y\n        };\n        r[i] = Math.random() * ((max_x - min_x) / 4);\n      }\n      for (var i = 0; i < num; i++) {\n        if (i > num - option.outlier) {\n          rand_pts[i] = {\n            x: Math.random() * (max_x - min_x) + min_x,\n            y: Math.random() * (max_y - min_y) + min_y\n          };\n        } else {\n          let rx = Math.random() * (2 * r[i % k]) + seeds[i % k].x - r[i % k];\n          let ry =\n            Math.sqrt(\n              Math.abs(\n                r[i % k] * r[i % k] -\n                  (rx - seeds[i % k].x) * (rx - seeds[i % k].x)\n              )\n            ) *\n              Math.pow(-1, (i % 2) + 1) +\n            seeds[i % k].y;\n\n          var errx = Math.random() * option.err - option.err / 2;\n          var erry = Math.random() * option.err - option.err / 2;\n          rx += errx;\n          ry += erry;\n\n          if (rx < min_x) rx += min_x;\n          if (rx > max_x) rx -= max_x;\n          if (ry > max_y) ry -= max_y;\n          if (ry < min_y) ry += min_y;\n\n          rand_pts[i] = {\n            x: rx,\n            y: ry\n          };\n        }\n      }\n      break;\n    }\n    default: {\n      console.log('default');\n      for (var i = 0; i < num; i++) {\n        rand_pts[i] = [\n          Math.random() * (max_x - min_x) + min_x,\n          Math.random() * (max_y - min_y) + min_y\n        ];\n      }\n      break;\n    }\n  }\n  return rand_pts;\n}\n","/* eslint-disable no-console */\r\nimport React, { useLayoutEffect, useRef, useState } from 'react';\r\nimport KMeans from 'k-meansjs';\r\nimport { Button, Input, Checkbox } from 'antd';\r\n\r\nimport './index.css';\r\nimport { draw, calculateLength } from './kmeans';\r\nimport { generateRandomPoints, generateClusterColors } from '../utils';\r\n\r\nconst KMeansComponent = ({ data }) => {\r\n  const canvas = useRef();\r\n  const maxX = 540;\r\n  const maxY = 540;\r\n  const [pointsCount, setPointsCount] = useState(100);\r\n  const [centersCount, setCentersCount] = useState(3);\r\n  const [clustersCount, setClustersCount] = useState(3);\r\n  const [isShowLengths, setIsShowLengths] = useState(false);\r\n\r\n  const [isWorking, setIsWorking] = useState(false);\r\n\r\n  const kmeansRun = context => {\r\n    setIsWorking(true);\r\n    context.clearRect(0, 0, canvas.width, canvas.height);\r\n\r\n    const clusterColors = generateClusterColors(clustersCount);\r\n\r\n    const kmeans = KMeans({\r\n      data,\r\n      k: centersCount\r\n    });\r\n\r\n    const fullLengths = Array.from({ length: centersCount }, () => []);\r\n\r\n    kmeans.on('iteration', self =>\r\n      draw(\r\n        fullLengths,\r\n        context,\r\n        clusterColors,\r\n        self.data,\r\n        self.means,\r\n        self.assignments,\r\n        self.extents,\r\n        self.ranges\r\n      )\r\n    );\r\n\r\n    kmeans.on('end', self => {\r\n      setIsWorking(false);\r\n      console.log(`Построение заняло кол-во итераций: ${self.iterations}`);\r\n      return calculateLength(\r\n        isShowLengths,\r\n        fullLengths,\r\n        context,\r\n        clusterColors,\r\n        self.data,\r\n        self.means,\r\n        self.assignments,\r\n        self.extents,\r\n        self.ranges\r\n      );\r\n    });\r\n\r\n    kmeans.run({\r\n      delay: 50\r\n    });\r\n  };\r\n\r\n  useLayoutEffect(() => {\r\n    const context = canvas.current.getContext('2d');\r\n\r\n    kmeansRun(context);\r\n  }, []);\r\n\r\n  const handleOnChangePointsCount = e => setPointsCount(e.target.value);\r\n\r\n  const handleOnChangeCentersCount = e => setCentersCount(e.target.value);\r\n\r\n  const handleOnChangeClustersCount = e => setClustersCount(e.target.value);\r\n\r\n  const handleRun = () => {\r\n    kmeansRun(canvas.current.getContext('2d'));\r\n  };\r\n\r\n  const onChengeIsShowLengths = e => setIsShowLengths(e.target.checked);\r\n\r\n  return (\r\n    <div className=\"k-means-box\">\r\n      K-means\r\n      <canvas ref={canvas} id=\"canvas\" width={maxX} height={maxY} />\r\n      <div className=\"controls\">\r\n        <Input\r\n          placeholder=\"Количество точек (10)\"\r\n          onChange={handleOnChangePointsCount}\r\n          allowClear\r\n        />\r\n        <Input\r\n          placeholder=\"Количество центров (3)\"\r\n          onChange={handleOnChangeCentersCount}\r\n          allowClear\r\n        />\r\n        <Input\r\n          placeholder=\"Количество кластеров (3)\"\r\n          onChange={handleOnChangeClustersCount}\r\n          allowClear\r\n        />\r\n        <div className=\"buttons\">\r\n          <Checkbox onChange={onChengeIsShowLengths}>\r\n            Показывать расстояния до цетройдов\r\n          </Checkbox>\r\n          <Button loading={isWorking} onClick={handleRun} type=\"primary\">\r\n            Перезапуск\r\n          </Button>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default KMeansComponent;\r\n","export function calculateLength(\r\n  isShowSubLength,\r\n  fullLengths,\r\n  context,\r\n  clusterColors,\r\n  data,\r\n  means,\r\n  assignments,\r\n  extents,\r\n  ranges\r\n) {\r\n  const { canvas } = context;\r\n\r\n  let point;\r\n  let i;\r\n  for (i = 0; i < assignments.length; i++) {\r\n    const meanIndex = assignments[i];\r\n    point = data[i];\r\n    const mean = means[meanIndex];\r\n\r\n    context.globalAlpha = 1;\r\n    context.save();\r\n\r\n    context.beginPath();\r\n\r\n    const x1 =\r\n      (point[0] - extents[0].min + 1) * (canvas.width / (ranges[0] + 2));\r\n    const y1 =\r\n      (point[1] - extents[1].min + 1) * (canvas.height / (ranges[1] + 2));\r\n\r\n    const x2 =\r\n      (mean[0] - extents[0].min + 1) * (canvas.width / (ranges[0] + 2));\r\n    const y2 =\r\n      (mean[1] - extents[1].min + 1) * (canvas.height / (ranges[1] + 2));\r\n\r\n    // Draw path from the point (moveTo) to the cluster centroid.\r\n    context.moveTo(x1, y1);\r\n    context.lineTo(x2, y2);\r\n\r\n    const length = Math.round(Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2));\r\n\r\n    if (isShowSubLength) {\r\n      console.log(\r\n        `Длина ${i}-го отрезка для ${assignments[i]} центра =`,\r\n        length\r\n      );\r\n\r\n      context.fillStyle = 'black';\r\n      context.textAlign = 'center';\r\n      context.textBaseline = 'bottom';\r\n\r\n      context.font = 'bold  7pt Arial';\r\n      context.fillText(length, x1, y1 - 5);\r\n    }\r\n\r\n    context.strokeStyle = clusterColors[assignments[i]];\r\n    context.stroke();\r\n\r\n    fullLengths[assignments[i]].push(length);\r\n\r\n    context.restore();\r\n  }\r\n\r\n  for (i = 0; i < means.length; i++) {\r\n    context.save();\r\n\r\n    point = means[i];\r\n\r\n    context.globalAlpha = 1;\r\n    context.fillStyle = 'black';\r\n    const x =\r\n      (point[0] - extents[0].min + 1) * (canvas.width / (ranges[0] + 2));\r\n    const y =\r\n      (point[1] - extents[1].min + 1) * (canvas.width / (ranges[1] + 2));\r\n\r\n    context.translate(x, y);\r\n\r\n    context.beginPath();\r\n    context.arc(0, 0, 5, 0, Math.PI * 2, true);\r\n    context.fill();\r\n    context.closePath();\r\n\r\n    const defLength = Math.round(\r\n      fullLengths[i].reduce((sum, curr) => sum + curr) / fullLengths[i].length\r\n    );\r\n\r\n    context.shadowColor = clusterColors[i];\r\n    context.shadowOffsetX = 0;\r\n    context.shadowOffsetY = 0;\r\n    context.shadowBlur = 3;\r\n\r\n    context.fillStyle = 'black';\r\n    context.font = 'bold 10pt Arial';\r\n    context.fillText(defLength, 10, -10);\r\n\r\n    context.restore();\r\n  }\r\n  return fullLengths;\r\n}\r\n\r\nexport function draw(\r\n  fullLengths,\r\n  context,\r\n  clusterColors,\r\n  data,\r\n  means,\r\n  assignments,\r\n  extents,\r\n  ranges\r\n) {\r\n  const { canvas } = context;\r\n\r\n  // Slightly clear the canvas to make new draws visible.\r\n  context.fillStyle = 'rgba(255,255,255, 1)';\r\n  context.fillRect(0, 0, canvas.width, canvas.height);\r\n\r\n  let point;\r\n  let i;\r\n  /* Iterate though points draw line from their origin to their cluster centroid.\r\n   * `assignments` contains cluster centroid index for each point.\r\n   */\r\n  for (i = 0; i < assignments.length; i++) {\r\n    const meanIndex = assignments[i];\r\n\r\n    point = data[i];\r\n    const mean = means[meanIndex];\r\n\r\n    // Make lines that will get drawn alpha transparent.\r\n    context.globalAlpha = 0.7;\r\n\r\n    // Push current state onto the stack.\r\n    context.save();\r\n\r\n    context.beginPath();\r\n\r\n    // Begin path from current point origin.\r\n    const x1 =\r\n      (point[0] - extents[0].min + 1) * (canvas.width / (ranges[0] + 2));\r\n    const y1 =\r\n      (point[1] - extents[1].min + 1) * (canvas.height / (ranges[1] + 2));\r\n\r\n    const x2 =\r\n      (mean[0] - extents[0].min + 1) * (canvas.width / (ranges[0] + 2));\r\n    const y2 =\r\n      (mean[1] - extents[1].min + 1) * (canvas.height / (ranges[1] + 2));\r\n\r\n    // Draw path from the point (moveTo) to the cluster centroid.\r\n    context.moveTo(x1, y1);\r\n    context.lineTo(x2, y2);\r\n\r\n    // Draw a stroke on the path to make it visible.\r\n\r\n    context.strokeStyle = 'black';\r\n\r\n    context.stroke();\r\n\r\n    context.restore();\r\n  }\r\n\r\n  // Plot every point onto canvas.\r\n  for (i = 0; i < data.length; i++) {\r\n    context.save();\r\n\r\n    point = data[i];\r\n\r\n    // Make style fully opaque.\r\n    context.globalAlpha = 1;\r\n\r\n    // Move canvas origin on the grid to current point position.\r\n    context.translate(\r\n      (point[0] - extents[0].min + 1) * (canvas.width / (ranges[0] + 2)),\r\n      (point[1] - extents[1].min + 1) * (canvas.width / (ranges[1] + 2))\r\n    );\r\n\r\n    context.beginPath();\r\n\r\n    // Draw point circle.\r\n    context.arc(0, 0, 5, 0, Math.PI * 2, true);\r\n\r\n    // Set the color for current point based on which cluster it belongs to.\r\n    context.strokeStyle = clusterColors[assignments[i]];\r\n\r\n    // Draw a stroke to make circle visible.\r\n    context.stroke();\r\n    context.closePath();\r\n\r\n    context.restore();\r\n  }\r\n\r\n  // console.log('means', means);\r\n\r\n  // Draw cluster centroids (means).\r\n  for (i = 0; i < means.length; i++) {\r\n    context.save();\r\n\r\n    point = means[i];\r\n\r\n    context.globalAlpha = 0.5;\r\n    context.fillStyle = clusterColors[i];\r\n    context.translate(\r\n      (point[0] - extents[0].min + 1) * (canvas.width / (ranges[0] + 2)),\r\n      (point[1] - extents[1].min + 1) * (canvas.width / (ranges[1] + 2))\r\n    );\r\n    context.beginPath();\r\n    context.arc(0, 0, 5, 0, Math.PI * 2, true);\r\n    context.fill();\r\n    context.closePath();\r\n\r\n    context.restore();\r\n  }\r\n}\r\n","/* eslint-disable react/prop-types */\n/* eslint-disable no-console */\nimport React, { useLayoutEffect, useRef } from 'react';\nimport sdbscan from 'sdbscan';\nimport dbscan from 'dbscanjs';\n\nimport { generateClusterColors } from '../utils';\nimport { draw } from './utils';\n\nimport './index.css';\n\nconst distance = (a, b) => {\n  const x = Math.pow(a[0] - b[0], 2);\n  const y = Math.pow(a[1] - b[1], 2);\n  return Math.sqrt(x + y);\n};\n\nconst DbscanComponent = ({ data, ranges, extents, maxX, maxY }) => {\n  const canvas = useRef();\n\n  useLayoutEffect(() => {\n    const context = canvas.current.getContext('2d');\n\n    console.log('data', data);\n\n    const epsilon = 150;\n    const minPts = 10;\n\n    // const { clusters, noise } = sdbscan(data, epsilon, minPts);\n    // console.log('clusters', clusters);\n    // console.log('noise', noise);\n    // const colors = generateClusterColors(clusters.length);\n\n    const labels = dbscan(data, distance, epsilon, minPts);\n\n    const uniqLabels = Array.from(new Set(labels));\n    console.log('uniqLabels', uniqLabels);\n\n    const colors = generateClusterColors(uniqLabels.length);\n\n    draw(context, data, labels, colors, extents, ranges);\n  }, []);\n\n  return (\n    <div className=\"k-means-box\">\n      DBSCAN\n      <canvas ref={canvas} id=\"canvas\" width={maxX} height={maxY} />\n    </div>\n  );\n};\n\nexport default DbscanComponent;\n","export function draw(context, data, labels, colors, extents, ranges) {\n  const { canvas } = context;\n\n  // Slightly clear the canvas to make new draws visible.\n  context.fillStyle = 'rgba(255,255,255, 1)';\n  context.fillRect(0, 0, canvas.width, canvas.height);\n\n  let point;\n  let i;\n\n  console.log(data);\n\n  // Plot every point onto canvas.\n  for (i = 0; i < data.length; i++) {\n    context.save();\n\n    point = data[i];\n\n    // Make style fully opaque.\n    context.globalAlpha = 1;\n\n    // Move canvas origin on the grid to current point position.\n    context.translate(\n      (point[0] - extents[0].min + 1) * (canvas.width / (ranges[0] + 2)),\n      (point[1] - extents[1].min + 1) * (canvas.width / (ranges[1] + 2))\n    );\n\n    // context.translate(point[0], point[1]);\n\n    // context.translate(10, 10);\n\n    context.beginPath();\n\n    // Draw point circle.\n    context.arc(0, 0, 5, 0, Math.PI * 2, true);\n\n    const flag = labels[i];\n    if (flag === -1) {\n      context.strokeStyle = colors[labels[i]];\n      context.stroke();\n    } else {\n      context.fillStyle = colors[labels[i]];\n      context.shadowColor = colors[labels[i]];\n      context.shadowBlur = 20;\n      context.shadowOffsetX = 0;\n      context.shadowOffsetY = 0;\n      context.fill();\n    }\n\n    // Set the color for current point based on which cluster it belongs to.\n\n    // context.strokeStyle = 'black';\n\n    // Draw a stroke to make circle visible.\n\n    context.closePath();\n\n    context.restore();\n  }\n}\n","/* eslint-disable no-console */\nimport React, { useEffect, useState } from 'react';\nimport { Tabs } from 'antd';\nimport KMeansComponent from './k-means';\n\nimport './index.css';\nimport DbscanComponent from './dbscan';\nimport { generateRandomPoints } from './utils';\n\nconst { TabPane } = Tabs;\n\nconst generateData = (pointsCount, rangeX, rangeY, offset) => {\n  const data = generateRandomPoints(\n    offset,\n    rangeX - offset,\n    offset,\n    rangeY - offset,\n    pointsCount,\n    {\n      name: 'linear',\n      scope: 5,\n      err: 150\n    }\n    // {\n    //   name: 'circular',\n    //   scope: 0,\n    //   k: 3,\n    //   err: 0,\n    //   outlier: 40\n    // }\n  ).map(point => Object.values(point));\n\n  const Xxes = [];\n  const Yxes = [];\n  data.forEach(([x, y]) => {\n    Xxes.push(x);\n    Yxes.push(y);\n  });\n\n  const extents = [\n    {\n      min: Math.min.apply(null, Xxes),\n      max: Math.max.apply(null, Xxes)\n    },\n    {\n      min: Math.min.apply(null, Yxes),\n      max: Math.max.apply(null, Yxes)\n    }\n  ];\n\n  const dataExtentRanges = () => {\n    const ranges = [];\n\n    for (let i = 0; i < extents.length; i++) {\n      ranges[i] = extents[i].max - extents[i].min;\n    }\n\n    return ranges;\n  };\n\n  return { data, extents, ranges: dataExtentRanges() };\n};\n\nconst Clustering = () => {\n  const maxX = 540;\n  const maxY = 540;\n  const offset = 20;\n  const [generatedData, setGeneratedData] = useState(\n    generateData(100, maxX, maxY, offset)\n  );\n\n  useEffect(() => {\n    // setGeneratedData(data);\n  }, []);\n  return (\n    <div className=\"clustering-box\">\n      <Tabs defaultActiveKey=\"2\">\n        <TabPane tab=\"K-MEANS\" key=\"1\">\n          <KMeansComponent\n            data={generatedData.data}\n            maxX={maxX}\n            maxY={maxY}\n            offset={offset}\n          />\n        </TabPane>\n        <TabPane tab=\"DBSCAN\" key=\"2\">\n          <DbscanComponent\n            data={generatedData.data}\n            ranges={generatedData.ranges}\n            extents={generatedData.extents}\n            maxX={maxX}\n            maxY={maxY}\n            offset={offset}\n          />\n        </TabPane>\n      </Tabs>\n    </div>\n  );\n};\n\nexport default Clustering;\n","import React from 'react';\r\n// import RabbitAuth from './components/rabbit-auth';\r\n// import TestBox from './components/test-box';\r\nimport Clustering from './components/clustering';\r\n\r\nimport './App.css';\r\n\r\nconst App = () => {\r\n  return (\r\n    <div className=\"App\">\r\n      {/* <RabbitAuth /> */}\r\n      {/* <TestBox /> */}\r\n      {<Clustering />}\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default App;\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\n\r\nReactDOM.render(<App />, document.getElementById('root'));\r\n"],"sourceRoot":""}