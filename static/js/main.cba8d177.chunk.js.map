{"version":3,"sources":["components/clustering/utils.js","components/clustering/k-means/info.js","components/clustering/k-means/index.js","components/clustering/k-means/kmeans.js","components/clustering/dbscan/info.js","components/clustering/dbscan/index.js","components/clustering/dbscan/utils.js","components/clustering/index.js","App.js","index.js"],"names":["generateClusterColors","size","colors","i","push","faker","internet","color","getOption","randomization","option","name","scope","err","k","outlier","generateData","pointsCount","rangeX","rangeY","offset","data","min_x","max_x","min_y","max_y","num","rand_pts","x","Math","random","y","lx","ly","errx","erry","r","seeds","length","rx","ry","sqrt","abs","pow","generateRandomPoints","map","point","Object","values","Xxes","Yxes","forEach","extents","min","apply","max","ranges","dataExtentRanges","Title","Paragraph","KMeansInfoComponent","Text","className","level","KMeansComponent","maxX","maxY","isKmeansWorking","setIsKmeansWorking","canvas","useRef","useState","centersCount","setCentersCount","isShowLengths","setIsShowLengths","mainLengths","setMainLengths","clusterColors","setClusterColors","infoVisible","setInfoVisible","kmeansRun","context","clearRect","width","height","fillStyle","fillRect","generateColors","kmeans","KMeans","fullLengths","Array","from","on","self","means","assignments","meanIndex","mean","globalAlpha","save","beginPath","x1","y1","x2","y2","moveTo","lineTo","strokeStyle","stroke","restore","translate","arc","PI","closePath","fill","draw","console","log","iterations","calculatedLengths","isShowSubLength","round","textAlign","textBaseline","font","fillText","defLength","reduce","sum","curr","measureText","calculateLength","run","delay","useLayoutEffect","current","getContext","description","cluster","index","key","style","border","background","type","theme","onClick","visible","closable","onClose","ref","id","marginRight","placeholder","onChange","e","target","value","allowClear","message","checked","loading","DbscanInfoComponent","distance","a","b","DbscanComponent","epsilon","setEpsilon","minPts","setMinPts","clustersCount","setClustersCount","noisesCount","setNoisesCount","dbScanRun","labels","dbscan","uniqLabels","Set","filter","label","shadowColor","shadowBlur","shadowOffsetX","shadowOffsetY","TabPane","Option","Clustering","setRandomization","setPointsCount","generatedData","setGeneratedData","operations","disabled","icon","defaultActiveKey","tabBarExtraContent","tab","App","ReactDOM","render","document","getElementById"],"mappings":"gdAiBO,SAASA,EAAsBC,GAGpC,IAFA,IAAMC,EAAS,GAENC,EAAI,EAAGA,EAAIF,EAAME,IACxBD,EAAOE,KAAKC,IAAMC,SAASC,SAE7B,OAAOL,EAGF,IAAMM,EAAY,SAAAC,GACvB,IAAIC,EACJ,OAAQD,GACN,IAAK,SACHC,EAAS,CACPC,KAAM,SACNC,MAAO,EACPC,IAAK,KAEP,MAEF,IAAK,WACHH,EAAS,CACPC,KAAM,WACNG,EAAG,GACHD,IAAK,GACLE,QAAS,IAEX,MAEF,QACEL,EAAS,CACPC,KAAM,IAKZ,OAAOD,GAGIM,EAAe,SAACC,EAAaC,EAAQC,EAAQC,EAAQV,GAChE,IAAMW,EAwCD,SAA8BC,EAAOC,EAAOC,EAAOC,EAAOC,EAAKhB,GACpE,IAAMiB,EAAW,GACjB,OAAQjB,EAAOC,MACb,IAAK,SAGH,IAHc,IACNC,EAAeF,EAAfE,MAAOC,EAAQH,EAARG,IAENV,EAAI,EAAGA,EAAIuB,EAAKvB,IACvB,GAAIA,EAAU,GAANuB,EACNC,EAASxB,GAAK,CACZyB,EAAGC,KAAKC,UAAYP,EAAQD,GAASA,EACrCS,EAAGF,KAAKC,UAAYL,EAAQD,GAASA,OAElC,CACL,IAAMQ,EAAKH,KAAKC,UAAYP,EAAQD,GAASA,EACvCW,EAAKD,EAAKpB,EACVsB,EAAOL,KAAKC,SAAWjB,EAAMA,EAAM,EACnCsB,EAAON,KAAKC,SAAWjB,EAAMA,EAAM,EACzCc,EAASxB,GAAK,CACZyB,EAAGI,EAAKE,EACRH,EAAGE,EAAKE,GAId,MAEF,IAAK,WACH,IAAMC,EAAI,GACJC,EAAQ,GACNvB,EAAoBJ,EAApBI,EAAGC,EAAiBL,EAAjBK,QAASF,EAAQH,EAARG,IACpBwB,EAAMC,OAASxB,EACfsB,EAAEE,OAASxB,EACX,IAASX,EAAI,EAAGA,EAAIW,EAAGX,IACrBkC,EAAMlC,GAAK,CACTyB,EAAGC,KAAKC,UAAYP,EAAQD,GAASA,EACrCS,EAAGF,KAAKC,UAAYL,EAAQD,GAASA,GAEvCY,EAAEjC,GAAK0B,KAAKC,WAAaP,EAAQD,GAAS,GAE5C,IAASnB,EAAI,EAAGA,EAAIuB,EAAKvB,IACvB,GAAIA,EAAIuB,EAAMX,EACZY,EAASxB,GAAK,CACZyB,EAAGC,KAAKC,UAAYP,EAAQD,GAASA,EACrCS,EAAGF,KAAKC,UAAYL,EAAQD,GAASA,OAElC,CACL,IAAIe,EAAKV,KAAKC,UAAY,EAAIM,EAAEjC,EAAIW,IAAMuB,EAAMlC,EAAIW,GAAGc,EAAIQ,EAAEjC,EAAIW,GAC7D0B,EACFX,KAAKY,KACHZ,KAAKa,IACHN,EAAEjC,EAAIW,GAAKsB,EAAEjC,EAAIW,IACdyB,EAAKF,EAAMlC,EAAIW,GAAGc,IAAMW,EAAKF,EAAMlC,EAAIW,GAAGc,KAG/CC,KAAKc,KAAK,EAAIxC,EAAI,EAAK,GACzBkC,EAAMlC,EAAIW,GAAGiB,EAETG,EAAOL,KAAKC,SAAWjB,EAAMA,EAAM,EACnCsB,EAAON,KAAKC,SAAWjB,EAAMA,EAAM,GACzC0B,GAAML,GAGGZ,IAAOiB,GAAMjB,GAClBiB,EAAKhB,IAAOgB,GAAMhB,IAHtBiB,GAAML,GAIGV,IAAOe,GAAMf,GAClBe,EAAKhB,IAAOgB,GAAMhB,GAEtBG,EAASxB,GAAK,CACZyB,EAAGW,EACHR,EAAGS,GAIT,MAEF,QACE,IAASrC,EAAI,EAAGA,EAAIuB,EAAKvB,IACvBwB,EAASxB,GAAK,CACZ0B,KAAKC,UAAYP,EAAQD,GAASA,EAClCO,KAAKC,UAAYL,EAAQD,GAASA,GAM1C,OAAOG,EA5HMiB,CACXxB,EACAF,EAASE,EACTA,EACAD,EAASC,EACTH,EACAP,GACAmC,KAAI,SAAAC,GAAK,OAAIC,OAAOC,OAAOF,MAEvBG,EAAO,GACPC,EAAO,GACb7B,EAAK8B,SAAQ,YAAa,IAAD,mBAAVvB,EAAU,KAAPG,EAAO,KACvBkB,EAAK7C,KAAKwB,GACVsB,EAAK9C,KAAK2B,MAGZ,IAAMqB,EAAU,CACd,CACEC,IAAKxB,KAAKwB,IAAIC,MAAM,KAAML,GAC1BM,IAAK1B,KAAK0B,IAAID,MAAM,KAAML,IAE5B,CACEI,IAAKxB,KAAKwB,IAAIC,MAAM,KAAMJ,GAC1BK,IAAK1B,KAAK0B,IAAID,MAAM,KAAMJ,KAc9B,MAAO,CAAE7B,OAAM+B,UAASI,OAVC,WAGvB,IAFA,IAAMA,EAAS,GAENrD,EAAI,EAAGA,EAAIiD,EAAQd,OAAQnC,IAClCqD,EAAOrD,GAAKiD,EAAQjD,GAAGoD,IAAMH,EAAQjD,GAAGkD,IAG1C,OAAOG,EAGuBC,K,mBCzF1BC,E,IAAAA,MAAOC,E,IAAAA,UAyCAC,G,IAzCWC,KAEE,WAC1B,OACE,yBAAKC,UAAU,QACb,kBAACJ,EAAD,CAAOK,MAAO,GAAd,0FACA,kBAACJ,EAAD,gnCAKA,kBAACD,EAAD,CAAOK,MAAO,GAAd,oDACA,kBAACJ,EAAD,g9FAWA,kBAACD,EAAD,CAAOK,MAAO,GAAd,oDACA,kBAACJ,EAAD,KACE,4BACE,qsBAIA,mfAEgC,KAEhC,8NC4HKK,EAxJS,SAAC,GAMlB,IALL3C,EAKI,EALJA,KACA4C,EAII,EAJJA,KACAC,EAGI,EAHJA,KACAC,EAEI,EAFJA,gBACAC,EACI,EADJA,mBAEMC,EAASC,mBADX,EAEoCC,mBAAS,GAF7C,mBAEGC,EAFH,KAEiBC,EAFjB,OAGsCF,oBAAS,GAH/C,mBAGGG,EAHH,KAGkBC,EAHlB,OAIkCJ,mBAAS,IAJ3C,mBAIGK,EAJH,KAIgBC,EAJhB,OAKsCN,mBAAS,IAL/C,mBAKGO,EALH,KAKkBC,EALlB,OAMkCR,oBAAS,GAN3C,mBAMGS,EANH,KAMgBC,EANhB,KAQEC,EAAY,SAAAC,GAChBf,GAAmB,GACnBe,EAAQC,UAAU,EAAG,EAAGf,EAAOgB,MAAOhB,EAAOiB,QAC7CH,EAAQI,UAAY,UACpBJ,EAAQK,SAAS,EAAG,EAAGnB,EAAOgB,MAAOhB,EAAOiB,QAE5C,IAAMG,EAAiBzF,EAAsBwE,GAC7CO,EAAiBU,GACjB,IAAMC,EAASC,IAAO,CACpBtE,OACAP,EAAG0D,IAGCoB,EAAcC,MAAMC,KAAK,CAAExD,OAAQkC,IAAgB,iBAAM,MAE/DkB,EAAOK,GAAG,aAAa,SAAAC,GAAI,OC8DxB,SACLJ,EACAT,EACAL,EACAzD,EACA4E,EACAC,EACA9C,EACAI,GACC,IAOGV,EACA3C,EAPIkE,EAAWc,EAAXd,OAWR,IARAc,EAAQI,UAAY,uBACpBJ,EAAQK,SAAS,EAAG,EAAGnB,EAAOgB,MAAOhB,EAAOiB,QAOvCnF,EAAI,EAAGA,EAAI+F,EAAY5D,OAAQnC,IAAK,CACvC,IAAMgG,EAAYD,EAAY/F,GAE9B2C,EAAQzB,EAAKlB,GACb,IAAMiG,EAAOH,EAAME,GAGnBhB,EAAQkB,YAAc,GAGtBlB,EAAQmB,OAERnB,EAAQoB,YAGR,IAAMC,GACH1D,EAAM,GAAKM,EAAQ,GAAGC,IAAM,IAAMgB,EAAOgB,OAAS7B,EAAO,GAAK,IAC3DiD,GACH3D,EAAM,GAAKM,EAAQ,GAAGC,IAAM,IAAMgB,EAAOiB,QAAU9B,EAAO,GAAK,IAE5DkD,GACHN,EAAK,GAAKhD,EAAQ,GAAGC,IAAM,IAAMgB,EAAOgB,OAAS7B,EAAO,GAAK,IAC1DmD,GACHP,EAAK,GAAKhD,EAAQ,GAAGC,IAAM,IAAMgB,EAAOiB,QAAU9B,EAAO,GAAK,IAGjE2B,EAAQyB,OAAOJ,EAAIC,GACnBtB,EAAQ0B,OAAOH,EAAIC,GAInBxB,EAAQ2B,YAAc,QAEtB3B,EAAQ4B,SAER5B,EAAQ6B,UAIV,IAAK7G,EAAI,EAAGA,EAAIkB,EAAKiB,OAAQnC,IAC3BgF,EAAQmB,OAERxD,EAAQzB,EAAKlB,GAGbgF,EAAQkB,YAAc,EAGtBlB,EAAQ8B,WACLnE,EAAM,GAAKM,EAAQ,GAAGC,IAAM,IAAMgB,EAAOgB,OAAS7B,EAAO,GAAK,KAC9DV,EAAM,GAAKM,EAAQ,GAAGC,IAAM,IAAMgB,EAAOgB,OAAS7B,EAAO,GAAK,KAGjE2B,EAAQoB,YAGRpB,EAAQ+B,IAAI,EAAG,EAAG,EAAG,EAAa,EAAVrF,KAAKsF,IAAQ,GAGrChC,EAAQ2B,YAAchC,EAAcoB,EAAY/F,IAGhDgF,EAAQ4B,SACR5B,EAAQiC,YAERjC,EAAQ6B,UAMV,IAAK7G,EAAI,EAAGA,EAAI8F,EAAM3D,OAAQnC,IAC5BgF,EAAQmB,OAERxD,EAAQmD,EAAM9F,GAEdgF,EAAQkB,YAAc,GACtBlB,EAAQI,UAAYT,EAAc3E,GAClCgF,EAAQ8B,WACLnE,EAAM,GAAKM,EAAQ,GAAGC,IAAM,IAAMgB,EAAOgB,OAAS7B,EAAO,GAAK,KAC9DV,EAAM,GAAKM,EAAQ,GAAGC,IAAM,IAAMgB,EAAOgB,OAAS7B,EAAO,GAAK,KAEjE2B,EAAQoB,YACRpB,EAAQ+B,IAAI,EAAG,EAAG,EAAG,EAAa,EAAVrF,KAAKsF,IAAQ,GACrChC,EAAQkC,OACRlC,EAAQiC,YAERjC,EAAQ6B,UDzKNM,CACE1B,EACAT,EACAM,EACAO,EAAK3E,KACL2E,EAAKC,MACLD,EAAKE,YACLF,EAAK5C,QACL4C,EAAKxC,WAITkC,EAAOK,GAAG,OAAO,SAAAC,GACf5B,GAAmB,GACnBmD,QAAQC,IAAR,8LAAkDxB,EAAKyB,aACvD,IAAMC,ECxDL,SACLC,EACA/B,EACAT,EACAL,EACAzD,EACA4E,EACAC,EACA9C,EACAI,GACC,IAGGV,EACA3C,EAHIkE,EAAWc,EAAXd,OAIR,IAAKlE,EAAI,EAAGA,EAAI+F,EAAY5D,OAAQnC,IAAK,CACvC,IAAMgG,EAAYD,EAAY/F,GAC9B2C,EAAQzB,EAAKlB,GACb,IAAMiG,EAAOH,EAAME,GAEnBhB,EAAQkB,YAAc,EACtBlB,EAAQmB,OAERnB,EAAQoB,YAER,IAAMC,GACH1D,EAAM,GAAKM,EAAQ,GAAGC,IAAM,IAAMgB,EAAOgB,OAAS7B,EAAO,GAAK,IAC3DiD,GACH3D,EAAM,GAAKM,EAAQ,GAAGC,IAAM,IAAMgB,EAAOiB,QAAU9B,EAAO,GAAK,IAE5DkD,GACHN,EAAK,GAAKhD,EAAQ,GAAGC,IAAM,IAAMgB,EAAOgB,OAAS7B,EAAO,GAAK,IAC1DmD,GACHP,EAAK,GAAKhD,EAAQ,GAAGC,IAAM,IAAMgB,EAAOiB,QAAU9B,EAAO,GAAK,IAGjE2B,EAAQyB,OAAOJ,EAAIC,GACnBtB,EAAQ0B,OAAOH,EAAIC,GAEnB,IAAMrE,EAAST,KAAK+F,MAAM/F,KAAKY,KAAK,SAACiE,EAAKF,EAAO,GAAb,SAAkBG,EAAKF,EAAO,KAE9DkB,IACFJ,QAAQC,IAAR,yCACWrH,EADX,uFAC+B+F,EAAY/F,GAD3C,2CAEEmC,GAGF6C,EAAQI,UAAY,QACpBJ,EAAQ0C,UAAY,SACpB1C,EAAQ2C,aAAe,SAEvB3C,EAAQ4C,KAAO,kBACf5C,EAAQ6C,SAAS1F,EAAQkE,EAAIC,EAAK,IAGpCtB,EAAQ2B,YAAchC,EAAcoB,EAAY/F,IAChDgF,EAAQ4B,SAERnB,EAAYM,EAAY/F,IAAIC,KAAKkC,GAEjC6C,EAAQ6B,UAGV,IAAMU,EAAoB,GAE1B,IAAKvH,EAAI,EAAGA,EAAI8F,EAAM3D,OAAQnC,IAAK,CACjCgF,EAAQmB,OAERxD,EAAQmD,EAAM9F,GAEdgF,EAAQkB,YAAc,EACtBlB,EAAQI,UAAY,QACpB,IAAM3D,GACHkB,EAAM,GAAKM,EAAQ,GAAGC,IAAM,IAAMgB,EAAOgB,OAAS7B,EAAO,GAAK,IAC3DzB,GACHe,EAAM,GAAKM,EAAQ,GAAGC,IAAM,IAAMgB,EAAOgB,OAAS7B,EAAO,GAAK,IAEjE2B,EAAQ8B,UAAUrF,EAAGG,GAErBoD,EAAQoB,YACRpB,EAAQ+B,IAAI,EAAG,EAAG,EAAG,EAAa,EAAVrF,KAAKsF,IAAQ,GACrChC,EAAQkC,OACRlC,EAAQiC,YAER,IAAMa,EAAYpG,KAAK+F,MACrBhC,EAAYzF,GAAG+H,QAAO,SAACC,EAAKC,GAAN,OAAeD,EAAMC,KAAQxC,EAAYzF,GAAGmC,QAEpEoF,EAAkBtH,KAAK6H,GAtBU,IAuBzB5C,EAAUF,EAAQkD,YAAYJ,GAA9B5C,MACRF,EAAQI,UAAY,QACpBJ,EAAQK,SAAS,IAAK,GAAIH,EAAQ,GAAI,IAEtCF,EAAQI,UAAY,QACpBJ,EAAQ0C,UAAY,OACpB1C,EAAQ4C,KAAO,kBACf5C,EAAQ6C,SAASC,EAAW,IAAK,GAEjC9C,EAAQ6B,UAEV,OAAOU,ED3CuBY,CACxB5D,EACAkB,EACAT,EACAM,EACAO,EAAK3E,KACL2E,EAAKC,MACLD,EAAKE,YACLF,EAAK5C,QACL4C,EAAKxC,QAEPqB,EAAe6C,MAGjBhC,EAAO6C,IAAI,CACTC,MAAO,KAIXC,2BAAgB,WACd,GAAIpH,GAAQA,EAAKiB,OAAS,EAAG,CAC3B,IAAM6C,EAAUd,EAAOqE,QAAQC,WAAW,MAC1CzD,EAAUC,MAEX,CAAC9D,IAEJ,IAQMuH,EAAc9D,EAAcjC,KAAI,SAACgG,EAASC,GAAV,OACpC,yBACEhF,UAAU,mBACViF,IAAKF,EACLG,MAAO,CAAEC,OAAO,aAAD,OAAenE,EAAcgE,MAE5C,yBAAKhF,UAAU,gBACb,2EACA,6BAAMgF,IAER,yBAAKhF,UAAU,eACb,yBACEA,UAAU,cACVkF,MAAO,CAAEE,WAAW,GAAD,OAAKpE,EAAcgE,OAExC,yBAAKhF,UAAU,iBAAiBc,EAAYkE,SAKlD,OACE,yBAAKhF,UAAU,eACb,yBAAKA,UAAU,aAAf,UAEE,uBACEA,UAAU,YACVqF,KAAK,cACLC,MAAM,UACNC,QAAS,kBAAMpE,GAAe,MAEhC,uBACEI,MAAM,MACNiE,QAAStE,EACTuE,UAAU,EACVC,QAAS,kBAAMvE,GAAe,KAE9B,kBAAC,EAAD,QAGJ,4BACEwE,IAAKpF,EACLqF,GAAG,SACHrE,MAAOpB,EACPqB,OAAQpB,EACR8E,MAAO,CAAEW,YAAa3E,GAAe,UAEvC,yBAAKlB,UAAU,YACb,uBACE8F,YAAY,0HACZC,SAzD2B,SAAAC,GAAC,OAAIrF,EAAgBqF,EAAEC,OAAOC,QA0DzDC,YAAU,KAEV9F,GACA,uBACE+F,QAAO,+HAA2B1F,EAA3B,8VACPoE,YAAaA,EACbO,KAAK,SAIT,yBAAKrF,UAAU,WACb,uBAAU+F,SA/DY,SAAAC,GAAC,OAAInF,EAAiBmF,EAAEC,OAAOI,WA+DrD,iMAGA,uBAAQC,QAASjG,EAAiBkF,QAtExB,WAChBnE,EAAUb,EAAOqE,QAAQC,WAAW,QAqEwBQ,KAAK,WAA3D,oE,wCErJFzF,E,IAAAA,MAAOC,E,IAAAA,UA8FA0G,G,IA9FWxG,KAEE,WAC1B,OACE,yBAAKC,UAAU,QACb,kBAAC,EAAD,CAAOC,MAAO,GAAd,yFACA,kBAAC,EAAD,s9CAOA,kBAAC,EAAD,CAAOA,MAAO,GAAd,oDACA,kBAAC,EAAD,2kBAGE,kBAAC,EAAD,smCAMA,kBAAC,EAAD,4jCAMA,kBAAC,EAAD,s7CAQF,kBAAC,EAAD,CAAOA,MAAO,GAAd,4EACA,kBAAC,EAAD,KACE,4BACE,2bAIA,8yCAMA,0PACA,mgBAIA,qlBAMJ,kBAAC,EAAD,CAAOA,MAAO,GAAd,gEACA,kBAAC,EAAD,KACE,4BACE,u+BAKA,k4EAUA,8zBAKA,qmBC7EJuG,EAAW,SAACC,EAAGC,GACnB,IAAM5I,EAAC,SAAI2I,EAAE,GAAKC,EAAE,GAAO,GACrBzI,EAAC,SAAIwI,EAAE,GAAKC,EAAE,GAAO,GAC3B,OAAO3I,KAAKY,KAAKb,EAAIG,IA2FR0I,EAxFS,SAAC,GAA2C,IAAzCpJ,EAAwC,EAAxCA,KAAMmC,EAAkC,EAAlCA,OAAQJ,EAA0B,EAA1BA,QAASa,EAAiB,EAAjBA,KAAMC,EAAW,EAAXA,KAChDG,EAASC,mBADkD,EAEnCC,mBAAS,IAF0B,mBAE1DmG,EAF0D,KAEjDC,EAFiD,OAGrCpG,mBAAS,GAH4B,mBAG1DqG,EAH0D,KAGlDC,EAHkD,OAIvBtG,mBAAS,GAJc,mBAI1DuG,EAJ0D,KAI3CC,EAJ2C,OAK3BxG,mBAAS,GALkB,mBAK1DyG,EAL0D,KAK7CC,EAL6C,OAM3B1G,oBAAS,GANkB,mBAM1DS,EAN0D,KAM7CC,EAN6C,KAQ3DiG,EAAY,WAChB,IAAM/F,EAAUd,EAAOqE,QAAQC,WAAW,MAEpCwC,EAASC,IAAO/J,EAAMiJ,EAAUI,EAASE,GAEzCS,EAAaxF,MAAMC,KAAK,IAAIwF,IAAIH,IACtCF,EAAeE,EAAOI,QAAO,SAAAC,GAAK,OAAe,IAAXA,KAAclJ,QACpDyI,EAAiBM,EAAW/I,QAE5B,IAAMpC,EAASF,EAAsBqL,EAAW/I,SCnC7C,SAAc6C,EAAS9D,EAAM8J,EAAQjL,EAAQkD,EAASI,GAAS,IAOhEV,EACA3C,EAPIkE,EAAWc,EAAXd,OAUR,IAPAc,EAAQI,UAAY,uBACpBJ,EAAQK,SAAS,EAAG,EAAGnB,EAAOgB,MAAOhB,EAAOiB,QAMvCnF,EAAI,EAAGA,EAAIkB,EAAKiB,OAAQnC,IAAK,CAChCgF,EAAQmB,OAERxD,EAAQzB,EAAKlB,GAGbgF,EAAQkB,YAAc,EAGtBlB,EAAQ8B,WACLnE,EAAM,GAAKM,EAAQ,GAAGC,IAAM,IAAMgB,EAAOgB,OAAS7B,EAAO,GAAK,KAC9DV,EAAM,GAAKM,EAAQ,GAAGC,IAAM,IAAMgB,EAAOgB,OAAS7B,EAAO,GAAK,KAOjE2B,EAAQoB,YAGRpB,EAAQ+B,IAAI,EAAG,EAAG,EAAG,EAAa,EAAVrF,KAAKsF,IAAQ,IAGvB,IADDgE,EAAOhL,IAElBgF,EAAQ2B,YAAc5G,EAAOiL,EAAOhL,IACpCgF,EAAQ4B,WAER5B,EAAQI,UAAYrF,EAAOiL,EAAOhL,IAClCgF,EAAQsG,YAAcvL,EAAOiL,EAAOhL,IACpCgF,EAAQuG,WAAa,GACrBvG,EAAQwG,cAAgB,EACxBxG,EAAQyG,cAAgB,EACxBzG,EAAQkC,QASVlC,EAAQiC,YAERjC,EAAQ6B,WDlBRM,CAAKnC,EAAS9D,EAAM8J,EAAQjL,EAAQkD,EAASI,IAG/CiF,2BAAgB,WACdyC,MACC,CAAC7J,IAUJ,OACE,yBAAKyC,UAAU,cACb,yBAAKA,UAAU,aAAf,SAEE,uBACEqF,KAAK,cACLC,MAAM,UACNtF,UAAU,YACVuF,QAAS,kBAAMpE,GAAe,MAEhC,uBACEI,MAAM,MACNiE,QAAStE,EACTuE,UAAU,EACVC,QAAS,kBAAMvE,GAAe,KAE9B,kBAAC,EAAD,QAGJ,4BACEwE,IAAKpF,EACLqF,GAAG,SACHrE,MAAOpB,EACPqB,OAAQpB,EACR8E,MAAO,CAAEW,YAAa3E,GAAe,UAEvC,yBAAKlB,UAAU,YACb,uBACE8F,YAAY,cACZC,SAnCqB,SAAAC,GAAC,OAAIe,EAAUf,EAAEC,OAAOC,QAoC7CC,YAAU,IAEZ,uBACEL,YAAY,iBACZC,SA1CsB,SAAAC,GAAC,OAAIa,EAAWb,EAAEC,OAAOC,QA2C/CC,YAAU,IAEXa,GACC,uBACEZ,QAAO,4LAAsCY,EAAgB,GAC7DlC,YAAW,qPAAkDoC,GAC7D7B,KAAK,SAGT,yBAAKrF,UAAU,WACb,uBAAQuF,QAjDE,WAChB6B,KAgDkC/B,KAAK,WAAjC,oEExFF0C,E,IAAAA,QACAC,E,IAAAA,OA6FOC,EA3FI,WAAO,IAAD,EACmBxH,mBAAS,YAD5B,mBAChB9D,EADgB,KACDuL,EADC,OAEezH,mBAAS,KAFxB,mBAEhBtD,EAFgB,KAEHgL,EAFG,OAGuB1H,oBAAS,GAHhC,mBAGhBJ,EAHgB,KAGCC,EAHD,OASmBG,mBAAS,CAAElD,KAAM,KATpC,mBAShB6K,EATgB,KASDC,EATC,KAWvB1D,2BAAgB,WACd,IAAMpH,EAAOL,EACXC,EARS,IACA,IACE,EAUXT,EAAUC,IAEZ0L,EAAiB9K,GACjBkG,QAAQC,IAAI,kIAA0BnG,KACrC,CAACZ,IAEJ,IAgBM2L,EACJ,yBAAKtI,UAAU,cACb,uBACEuI,SAAUlI,EACVyF,YAAY,qGACZC,SAnB4B,SAAAG,GAAK,OAAIiC,EAAejC,IAoBpDC,YAAU,EACVjB,MAAO,CAAE3D,MAAO,KAChBhC,IAAK,GACLE,IAAK,MAEP,uBAAQ+I,KAAK,SAASjD,QAvBL,WACnB,IAAMhI,EAAOL,EACXC,EAxBS,IACA,IACE,EA0BXT,EAAUC,IAEZ0L,EAAiB9K,GACjBkG,QAAQC,IAAI,kIAA0BnG,IAcS+I,QAASjG,IACtD,uBACE6E,MAAO,CAAE3D,MAAO,KAChBuE,YAAY,kIACZC,SA/BwB,SAAAG,GAAK,OAAIgC,EAAiBhC,IAgClDA,MAAOvJ,EACP4L,SAAUlI,GAEV,kBAAC2H,EAAD,CAAQ9B,MAAM,UAAd,oDACA,kBAAC8B,EAAD,CAAQ9B,MAAM,YAAd,oDACA,kBAAC8B,EAAD,CAAQ9B,MAAM,IAAd,wEAKN,OACE,yBAAKlG,UAAU,kBACb,uBAAMyI,iBAAiB,IAAIC,mBAAoBJ,GAC7C,kBAACP,EAAD,CAASY,IAAI,UAAU1D,IAAI,KACzB,kBAAC,EAAD,CACE1H,KAAM6K,EAAc7K,KACpB4C,KAlEG,IAmEHC,KAlEG,IAmEHC,gBAAiBA,EACjBC,mBAAoBA,KAGxB,kBAACyH,EAAD,CAASY,IAAI,SAAS1D,IAAI,KACxB,kBAAC,EAAD,CACE1H,KAAM6K,EAAc7K,KACpBmC,OAAQ0I,EAAc1I,OACtBJ,QAAS8I,EAAc9I,QACvBa,KA7EG,IA8EHC,KA7EG,UCDAwI,G,QAVH,WACV,OACE,yBAAK5I,UAAU,OAGZ,kBAAC,EAAD,SCPP6I,IAASC,OAAO,kBAAC,EAAD,MAASC,SAASC,eAAe,U","file":"static/js/main.cba8d177.chunk.js","sourcesContent":["/* eslint-disable camelcase */\nimport faker from 'faker';\n\nexport function random(start, end) {\n  const dif = end - start;\n  return Math.random() * dif + start + 1;\n}\n\nexport function generateSampleData(points) {\n  const data = [];\n  // Generate random data\n  for (let i = 0; i < points; i++) {\n    data.push([random(0, 10), random(0, 10)]);\n  }\n  return data;\n}\n\nexport function generateClusterColors(size) {\n  const colors = [];\n  // Generate point color for each cluster.\n  for (let i = 0; i < size; i++) {\n    colors.push(faker.internet.color());\n  }\n  return colors;\n}\n\nexport const getOption = randomization => {\n  let option;\n  switch (randomization) {\n    case 'linear': {\n      option = {\n        name: 'linear',\n        scope: 2,\n        err: 200\n      };\n      break;\n    }\n    case 'circular': {\n      option = {\n        name: 'circular',\n        k: 25,\n        err: 20,\n        outlier: 30\n      };\n      break;\n    }\n    default: {\n      option = {\n        name: ''\n      };\n      break;\n    }\n  }\n  return option;\n};\n\nexport const generateData = (pointsCount, rangeX, rangeY, offset, option) => {\n  const data = generateRandomPoints(\n    offset,\n    rangeX - offset,\n    offset,\n    rangeY - offset,\n    pointsCount,\n    option\n  ).map(point => Object.values(point));\n\n  const Xxes = [];\n  const Yxes = [];\n  data.forEach(([x, y]) => {\n    Xxes.push(x);\n    Yxes.push(y);\n  });\n\n  const extents = [\n    {\n      min: Math.min.apply(null, Xxes),\n      max: Math.max.apply(null, Xxes)\n    },\n    {\n      min: Math.min.apply(null, Yxes),\n      max: Math.max.apply(null, Yxes)\n    }\n  ];\n\n  const dataExtentRanges = () => {\n    const ranges = [];\n\n    for (let i = 0; i < extents.length; i++) {\n      ranges[i] = extents[i].max - extents[i].min;\n    }\n\n    return ranges;\n  };\n\n  return { data, extents, ranges: dataExtentRanges() };\n};\n\nexport function generateRandomPoints(min_x, max_x, min_y, max_y, num, option) {\n  const rand_pts = [];\n  switch (option.name) {\n    case 'linear': {\n      const { scope, err } = option;\n\n      for (var i = 0; i < num; i++) {\n        if (i > num * 0.9) {\n          rand_pts[i] = {\n            x: Math.random() * (max_x - min_x) + min_x,\n            y: Math.random() * (max_y - min_y) + min_y\n          };\n        } else {\n          const lx = Math.random() * (max_x - min_x) + min_x;\n          const ly = lx * scope;\n          const errx = Math.random() * err - err / 2;\n          const erry = Math.random() * err - err / 2;\n          rand_pts[i] = {\n            x: lx + errx,\n            y: ly + erry\n          };\n        }\n      }\n      break;\n    }\n    case 'circular': {\n      const r = [];\n      const seeds = [];\n      const { k, outlier, err } = option;\n      seeds.length = k;\n      r.length = k;\n      for (var i = 0; i < k; i++) {\n        seeds[i] = {\n          x: Math.random() * (max_x - min_x) + min_x,\n          y: Math.random() * (max_y - min_y) + min_y\n        };\n        r[i] = Math.random() * ((max_x - min_x) / 4);\n      }\n      for (var i = 0; i < num; i++) {\n        if (i > num - outlier) {\n          rand_pts[i] = {\n            x: Math.random() * (max_x - min_x) + min_x,\n            y: Math.random() * (max_y - min_y) + min_y\n          };\n        } else {\n          let rx = Math.random() * (2 * r[i % k]) + seeds[i % k].x - r[i % k];\n          let ry =\n            Math.sqrt(\n              Math.abs(\n                r[i % k] * r[i % k] -\n                  (rx - seeds[i % k].x) * (rx - seeds[i % k].x)\n              )\n            ) *\n              Math.pow(-1, (i % 2) + 1) +\n            seeds[i % k].y;\n\n          const errx = Math.random() * err - err / 2;\n          const erry = Math.random() * err - err / 2;\n          rx += errx;\n          ry += erry;\n\n          if (rx < min_x) rx += min_x;\n          if (rx > max_x) rx -= max_x;\n          if (ry > max_y) ry -= max_y;\n          if (ry < min_y) ry += min_y;\n\n          rand_pts[i] = {\n            x: rx,\n            y: ry\n          };\n        }\n      }\n      break;\n    }\n    default: {\n      for (var i = 0; i < num; i++) {\n        rand_pts[i] = [\n          Math.random() * (max_x - min_x) + min_x,\n          Math.random() * (max_y - min_y) + min_y\n        ];\n      }\n      break;\n    }\n  }\n  return rand_pts;\n}\n","/* eslint-disable react/prop-types */\n/* eslint-disable no-console */\nimport React from 'react';\nimport { Typography } from 'antd';\n\nconst { Title, Paragraph, Text } = Typography;\n\nconst KMeansInfoComponent = () => {\n  return (\n    <div className=\"info\">\n      <Title level={3}>K-Means кластеризация</Title>\n      <Paragraph>\n        Классификация состоит в разбиении заданной выборки на непересекающиеся\n        подмножества, называемые кластерами, так, чтобы каждый кластер состоял\n        из схожих объектов, а объекты разных кластеров существенно отличались.\n      </Paragraph>\n      <Title level={4}>Алгоритм</Title>\n      <Paragraph>\n        Основная идея заключается в том, что на каждой итерации перевычисляется\n        центр масс для каждого кластера, полученного на предыдущем шаге, затем\n        векторы разбиваются на кластеры вновь в соответствии с тем, какой из\n        новых центров оказался ближе по выбранной метрике. Алгоритм завершается,\n        когда на какой-то итерации не происходит изменения внутрикластерного\n        расстояния. Это происходит за конечное число итераций, так как\n        количество возможных разбиений конечного множества конечно, а на каждом\n        шаге суммарное квадратичное отклонение V уменьшается, поэтому\n        зацикливание невозможно.\n      </Paragraph>\n      <Title level={4}>Проблемы</Title>\n      <Paragraph>\n        <ul>\n          <li>\n            Не гарантируется достижение глобального минимума суммарного\n            квадратичного отклонения V, а только одного из локальных минимумов.\n          </li>\n          <li>\n            Результат зависит от выбора исходных центров кластеров, их\n            оптимальный выбор неизвестен.{' '}\n          </li>\n          <li>Число кластеров надо знать заранее.</li>\n        </ul>\n      </Paragraph>\n    </div>\n  );\n};\n\nexport default KMeansInfoComponent;\n","/* eslint-disable react/prop-types */\r\n/* eslint-disable no-console */\r\nimport React, { useLayoutEffect, useRef, useState } from 'react';\r\nimport KMeans from 'k-meansjs';\r\nimport { Button, Input, Checkbox, Alert, Icon, Drawer } from 'antd';\r\n\r\nimport './index.css';\r\nimport { draw, calculateLength } from './kmeans';\r\nimport { generateClusterColors } from '../utils';\r\nimport KMeansInfoComponent from './info';\r\n\r\nconst KMeansComponent = ({\r\n  data,\r\n  maxX,\r\n  maxY,\r\n  isKmeansWorking,\r\n  setIsKmeansWorking\r\n}) => {\r\n  const canvas = useRef();\r\n  const [centersCount, setCentersCount] = useState(5);\r\n  const [isShowLengths, setIsShowLengths] = useState(false);\r\n  const [mainLengths, setMainLengths] = useState([]);\r\n  const [clusterColors, setClusterColors] = useState([]);\r\n  const [infoVisible, setInfoVisible] = useState(false);\r\n\r\n  const kmeansRun = context => {\r\n    setIsKmeansWorking(true);\r\n    context.clearRect(0, 0, canvas.width, canvas.height);\r\n    context.fillStyle = '#ffffff';\r\n    context.fillRect(0, 0, canvas.width, canvas.height);\r\n\r\n    const generateColors = generateClusterColors(centersCount);\r\n    setClusterColors(generateColors);\r\n    const kmeans = KMeans({\r\n      data,\r\n      k: centersCount\r\n    });\r\n\r\n    const fullLengths = Array.from({ length: centersCount }, () => []);\r\n\r\n    kmeans.on('iteration', self =>\r\n      draw(\r\n        fullLengths,\r\n        context,\r\n        generateColors,\r\n        self.data,\r\n        self.means,\r\n        self.assignments,\r\n        self.extents,\r\n        self.ranges\r\n      )\r\n    );\r\n\r\n    kmeans.on('end', self => {\r\n      setIsKmeansWorking(false);\r\n      console.log(`Построение заняло кол-во итераций: ${self.iterations}`);\r\n      const calculatedLengths = calculateLength(\r\n        isShowLengths,\r\n        fullLengths,\r\n        context,\r\n        generateColors,\r\n        self.data,\r\n        self.means,\r\n        self.assignments,\r\n        self.extents,\r\n        self.ranges\r\n      );\r\n      setMainLengths(calculatedLengths);\r\n    });\r\n\r\n    kmeans.run({\r\n      delay: 0\r\n    });\r\n  };\r\n\r\n  useLayoutEffect(() => {\r\n    if (data && data.length > 0) {\r\n      const context = canvas.current.getContext('2d');\r\n      kmeansRun(context);\r\n    }\r\n  }, [data]);\r\n\r\n  const handleOnChangeCentersCount = e => setCentersCount(e.target.value);\r\n\r\n  const handleRun = () => {\r\n    kmeansRun(canvas.current.getContext('2d'));\r\n  };\r\n\r\n  const onChengeIsShowLengths = e => setIsShowLengths(e.target.checked);\r\n\r\n  const description = clusterColors.map((cluster, index) => (\r\n    <div\r\n      className=\"clusterInfoBlock\"\r\n      key={cluster}\r\n      style={{ border: `1px solid ${clusterColors[index]}` }}\r\n    >\r\n      <div className=\"clusterTitle\">\r\n        <div>Кластер</div>\r\n        <div>{index}</div>\r\n      </div>\r\n      <div className=\"clusterInfo\">\r\n        <div\r\n          className=\"clusterMark\"\r\n          style={{ background: `${clusterColors[index]}` }}\r\n        />\r\n        <div className=\"clusterLength\">{mainLengths[index]}</div>\r\n      </div>\r\n    </div>\r\n  ));\r\n\r\n  return (\r\n    <div className=\"k-means-box\">\r\n      <div className=\"box-title\">\r\n        K-MEANS\r\n        <Icon\r\n          className=\"info-icon\"\r\n          type=\"info-circle\"\r\n          theme=\"twoTone\"\r\n          onClick={() => setInfoVisible(true)}\r\n        />\r\n        <Drawer\r\n          width=\"50%\"\r\n          visible={infoVisible}\r\n          closable={false}\r\n          onClose={() => setInfoVisible(false)}\r\n        >\r\n          <KMeansInfoComponent />\r\n        </Drawer>\r\n      </div>\r\n      <canvas\r\n        ref={canvas}\r\n        id=\"canvas\"\r\n        width={maxX}\r\n        height={maxY}\r\n        style={{ marginRight: infoVisible && 'auto' }}\r\n      />\r\n      <div className=\"controls\">\r\n        <Input\r\n          placeholder=\"Количество кластеров (5)\"\r\n          onChange={handleOnChangeCentersCount}\r\n          allowClear\r\n        />\r\n        {!isKmeansWorking && (\r\n          <Alert\r\n            message={`Полученные данные для ${centersCount} кластеров с расчитанными средними растояниями до точек кластера: `}\r\n            description={description}\r\n            type=\"info\"\r\n          />\r\n        )}\r\n\r\n        <div className=\"buttons\">\r\n          <Checkbox onChange={onChengeIsShowLengths}>\r\n            Показывать расстояния до цетройдов\r\n          </Checkbox>\r\n          <Button loading={isKmeansWorking} onClick={handleRun} type=\"primary\">\r\n            Перезапуск\r\n          </Button>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default KMeansComponent;\r\n","export function calculateLength(\r\n  isShowSubLength,\r\n  fullLengths,\r\n  context,\r\n  clusterColors,\r\n  data,\r\n  means,\r\n  assignments,\r\n  extents,\r\n  ranges\r\n) {\r\n  const { canvas } = context;\r\n\r\n  let point;\r\n  let i;\r\n  for (i = 0; i < assignments.length; i++) {\r\n    const meanIndex = assignments[i];\r\n    point = data[i];\r\n    const mean = means[meanIndex];\r\n\r\n    context.globalAlpha = 1;\r\n    context.save();\r\n\r\n    context.beginPath();\r\n\r\n    const x1 =\r\n      (point[0] - extents[0].min + 1) * (canvas.width / (ranges[0] + 2));\r\n    const y1 =\r\n      (point[1] - extents[1].min + 1) * (canvas.height / (ranges[1] + 2));\r\n\r\n    const x2 =\r\n      (mean[0] - extents[0].min + 1) * (canvas.width / (ranges[0] + 2));\r\n    const y2 =\r\n      (mean[1] - extents[1].min + 1) * (canvas.height / (ranges[1] + 2));\r\n\r\n    // Draw path from the point (moveTo) to the cluster centroid.\r\n    context.moveTo(x1, y1);\r\n    context.lineTo(x2, y2);\r\n\r\n    const length = Math.round(Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2));\r\n\r\n    if (isShowSubLength) {\r\n      console.log(\r\n        `Длина ${i}-го отрезка для ${assignments[i]} центра =`,\r\n        length\r\n      );\r\n\r\n      context.fillStyle = 'black';\r\n      context.textAlign = 'center';\r\n      context.textBaseline = 'bottom';\r\n\r\n      context.font = 'bold  7pt Arial';\r\n      context.fillText(length, x1, y1 - 5);\r\n    }\r\n\r\n    context.strokeStyle = clusterColors[assignments[i]];\r\n    context.stroke();\r\n\r\n    fullLengths[assignments[i]].push(length);\r\n\r\n    context.restore();\r\n  }\r\n\r\n  const calculatedLengths = [];\r\n\r\n  for (i = 0; i < means.length; i++) {\r\n    context.save();\r\n\r\n    point = means[i];\r\n\r\n    context.globalAlpha = 1;\r\n    context.fillStyle = 'black';\r\n    const x =\r\n      (point[0] - extents[0].min + 1) * (canvas.width / (ranges[0] + 2));\r\n    const y =\r\n      (point[1] - extents[1].min + 1) * (canvas.width / (ranges[1] + 2));\r\n\r\n    context.translate(x, y);\r\n\r\n    context.beginPath();\r\n    context.arc(0, 0, 5, 0, Math.PI * 2, true);\r\n    context.fill();\r\n    context.closePath();\r\n\r\n    const defLength = Math.round(\r\n      fullLengths[i].reduce((sum, curr) => sum + curr) / fullLengths[i].length\r\n    );\r\n    calculatedLengths.push(defLength);\r\n    const { width } = context.measureText(defLength);\r\n    context.fillStyle = 'white';\r\n    context.fillRect(10, -20, width + 10, 12);\r\n\r\n    context.fillStyle = 'black';\r\n    context.textAlign = 'left';\r\n    context.font = 'bold 14px Arial';\r\n    context.fillText(defLength, 10, -9);\r\n\r\n    context.restore();\r\n  }\r\n  return calculatedLengths;\r\n}\r\n\r\nexport function draw(\r\n  fullLengths,\r\n  context,\r\n  clusterColors,\r\n  data,\r\n  means,\r\n  assignments,\r\n  extents,\r\n  ranges\r\n) {\r\n  const { canvas } = context;\r\n\r\n  // Slightly clear the canvas to make new draws visible.\r\n  context.fillStyle = 'rgba(255,255,255, 1)';\r\n  context.fillRect(0, 0, canvas.width, canvas.height);\r\n\r\n  let point;\r\n  let i;\r\n  /* Iterate though points draw line from their origin to their cluster centroid.\r\n   * `assignments` contains cluster centroid index for each point.\r\n   */\r\n  for (i = 0; i < assignments.length; i++) {\r\n    const meanIndex = assignments[i];\r\n\r\n    point = data[i];\r\n    const mean = means[meanIndex];\r\n\r\n    // Make lines that will get drawn alpha transparent.\r\n    context.globalAlpha = 0.7;\r\n\r\n    // Push current state onto the stack.\r\n    context.save();\r\n\r\n    context.beginPath();\r\n\r\n    // Begin path from current point origin.\r\n    const x1 =\r\n      (point[0] - extents[0].min + 1) * (canvas.width / (ranges[0] + 2));\r\n    const y1 =\r\n      (point[1] - extents[1].min + 1) * (canvas.height / (ranges[1] + 2));\r\n\r\n    const x2 =\r\n      (mean[0] - extents[0].min + 1) * (canvas.width / (ranges[0] + 2));\r\n    const y2 =\r\n      (mean[1] - extents[1].min + 1) * (canvas.height / (ranges[1] + 2));\r\n\r\n    // Draw path from the point (moveTo) to the cluster centroid.\r\n    context.moveTo(x1, y1);\r\n    context.lineTo(x2, y2);\r\n\r\n    // Draw a stroke on the path to make it visible.\r\n\r\n    context.strokeStyle = 'black';\r\n\r\n    context.stroke();\r\n\r\n    context.restore();\r\n  }\r\n\r\n  // Plot every point onto canvas.\r\n  for (i = 0; i < data.length; i++) {\r\n    context.save();\r\n\r\n    point = data[i];\r\n\r\n    // Make style fully opaque.\r\n    context.globalAlpha = 1;\r\n\r\n    // Move canvas origin on the grid to current point position.\r\n    context.translate(\r\n      (point[0] - extents[0].min + 1) * (canvas.width / (ranges[0] + 2)),\r\n      (point[1] - extents[1].min + 1) * (canvas.width / (ranges[1] + 2))\r\n    );\r\n\r\n    context.beginPath();\r\n\r\n    // Draw point circle.\r\n    context.arc(0, 0, 5, 0, Math.PI * 2, true);\r\n\r\n    // Set the color for current point based on which cluster it belongs to.\r\n    context.strokeStyle = clusterColors[assignments[i]];\r\n\r\n    // Draw a stroke to make circle visible.\r\n    context.stroke();\r\n    context.closePath();\r\n\r\n    context.restore();\r\n  }\r\n\r\n  // console.log('means', means);\r\n\r\n  // Draw cluster centroids (means).\r\n  for (i = 0; i < means.length; i++) {\r\n    context.save();\r\n\r\n    point = means[i];\r\n\r\n    context.globalAlpha = 0.5;\r\n    context.fillStyle = clusterColors[i];\r\n    context.translate(\r\n      (point[0] - extents[0].min + 1) * (canvas.width / (ranges[0] + 2)),\r\n      (point[1] - extents[1].min + 1) * (canvas.width / (ranges[1] + 2))\r\n    );\r\n    context.beginPath();\r\n    context.arc(0, 0, 5, 0, Math.PI * 2, true);\r\n    context.fill();\r\n    context.closePath();\r\n\r\n    context.restore();\r\n  }\r\n}\r\n","/* eslint-disable react/prop-types */\n/* eslint-disable no-console */\nimport React from 'react';\nimport { Typography } from 'antd';\n\nconst { Title, Paragraph, Text } = Typography;\n\nconst DbscanInfoComponent = () => {\n  return (\n    <div className=\"info\">\n      <Title level={3}>Кластеризация DBSCAN</Title>\n      <Paragraph>\n        Это алгоритм кластеризации, основанной на плотности — если дан набор\n        точек в некотором пространстве, алгоритм группирует вместе точки,\n        которые тесно расположены, помечая как выбросы точки, которые находятся\n        одиноко в областях с малой плотностью (ближайшие соседи которых лежат\n        далеко).\n      </Paragraph>\n      <Title level={4}>Алгоритм</Title>\n      <Paragraph>\n        DBSCAN требует задания двух параметров: epsilon и минимального числа\n        точек, которые должны образовывать плотную область (minPts).\n        <Paragraph>\n          Алгоритм начинается с произвольной точки, которая ещё не\n          просматривалась. Выбирается epsilon - окрестность точки и, если она\n          содержит достаточно много точек, образуется кластер, в противном\n          случае точка помечается как шум.\n        </Paragraph>\n        <Paragraph>\n          Заметим, что эта точка может быть позже найдена в epsilon -\n          окрестности другой точки и включена в какой-то кластер. Если точка\n          найдена как плотная точка кластера, её epsilon - окрестность также\n          является частью этого кластера.\n        </Paragraph>\n        <Paragraph>\n          Следовательно, все точки, найденные в epsilon - окрестности этой\n          точки, добавляются к кластеру. Этот процесс продолжается, пока не\n          будет найден связный по плотности кластер. Затем выбирается и\n          обрабатывается новая непосещённая точка, что ведёт к обнаружению\n          следующего кластера или шума.\n        </Paragraph>\n      </Paragraph>\n      <Title level={4}>Преимущества</Title>\n      <Paragraph>\n        <ul>\n          <li>\n            DBSCAN не требует спецификации числа кластеров в данных в отличие от\n            метода k-средних.\n          </li>\n          <li>\n            DBSCAN может найти кластеры произвольной формы. Он может найти даже\n            кластеры полностью окружённые (но не связанные с) другими\n            кластерами. Благодаря параметру MinPts уменьшается так называемый\n            эффект одной связи (связь различных кластеров тонкой линией точек).\n          </li>\n          <li>DBSCAN имеет понятие шума и устойчив к выбросам.</li>\n          <li>\n            DBSCAN требует лишь двух параметров и большей частью нечувствителен\n            к порядку точек в базе данных.\n          </li>\n          <li>\n            Параметры minPts и epsilon могут быть установлены экспертами в\n            рассматриваемой области, если данные хорошо понимаются.\n          </li>\n        </ul>\n      </Paragraph>\n      <Title level={4}>Недостатки</Title>\n      <Paragraph>\n        <ul>\n          <li>\n            DBSCAN не полностью однозначен — краевые точки, которые могут быть\n            достигнуты из более чем одного кластера, могут принадлежать любому\n            из этих кластеров, что зависит от порядка просмотра точек.\n          </li>\n          <li>\n            Качество DBSCAN зависит от измерения расстояния, используемого в\n            функции regionQuery(P,ε). Наиболее часто используемой метрикой\n            расстояний является евклидова метрика. Особенно для кластеризации\n            данных высокой размерности[en] эта метрика может оказаться почти\n            бесполезной ввиду так называемого «проклятия размерности», что\n            делает трудным делом нахождение подходящего значения epsilon . Этот\n            эффект, однако, присутствует в любом другом алгоритме, основанном на\n            евклидовом расстоянии.\n          </li>\n          <li>\n            DBSCAN не может хорошо кластеризовать наборы данных с большой\n            разницей в плотности, поскольку не удается выбрать приемлемую для\n            всех кластеров комбинацию minPts-epsilon\n          </li>\n          <li>\n            Если данные и масштаб не вполне хорошо поняты, выбор осмысленного\n            порога расстояния epsilon может оказаться трудным.\n          </li>\n        </ul>\n      </Paragraph>\n    </div>\n  );\n};\n\nexport default DbscanInfoComponent;\n","/* eslint-disable react/prop-types */\n/* eslint-disable no-console */\nimport React, { useLayoutEffect, useRef, useState } from 'react';\nimport dbscan from 'dbscanjs';\n\nimport { Input, Button, Alert, Icon, Drawer } from 'antd';\nimport { generateClusterColors } from '../utils';\nimport { draw } from './utils';\n\nimport './index.css';\nimport DbscanInfoComponent from './info';\n\nconst distance = (a, b) => {\n  const x = (a[0] - b[0]) ** 2;\n  const y = (a[1] - b[1]) ** 2;\n  return Math.sqrt(x + y);\n};\n\nconst DbscanComponent = ({ data, ranges, extents, maxX, maxY }) => {\n  const canvas = useRef();\n  const [epsilon, setEpsilon] = useState(30);\n  const [minPts, setMinPts] = useState(5);\n  const [clustersCount, setClustersCount] = useState(0);\n  const [noisesCount, setNoisesCount] = useState(0);\n  const [infoVisible, setInfoVisible] = useState(false);\n\n  const dbScanRun = () => {\n    const context = canvas.current.getContext('2d');\n\n    const labels = dbscan(data, distance, epsilon, minPts);\n\n    const uniqLabels = Array.from(new Set(labels));\n    setNoisesCount(labels.filter(label => label === -1).length);\n    setClustersCount(uniqLabels.length);\n\n    const colors = generateClusterColors(uniqLabels.length);\n\n    draw(context, data, labels, colors, extents, ranges);\n  };\n\n  useLayoutEffect(() => {\n    dbScanRun();\n  }, [data]);\n\n  const handleOnChangeEpsilon = e => setEpsilon(e.target.value);\n\n  const handleOnChangeMinPts = e => setMinPts(e.target.value);\n\n  const handleRun = () => {\n    dbScanRun();\n  };\n\n  return (\n    <div className=\"dbscan-box\">\n      <div className=\"box-title\">\n        DBSCAN\n        <Icon\n          type=\"info-circle\"\n          theme=\"twoTone\"\n          className=\"info-icon\"\n          onClick={() => setInfoVisible(true)}\n        />\n        <Drawer\n          width=\"50%\"\n          visible={infoVisible}\n          closable={false}\n          onClose={() => setInfoVisible(false)}\n        >\n          <DbscanInfoComponent />\n        </Drawer>\n      </div>\n      <canvas\n        ref={canvas}\n        id=\"canvas\"\n        width={maxX}\n        height={maxY}\n        style={{ marginRight: infoVisible && 'auto' }}\n      />\n      <div className=\"controls\">\n        <Input\n          placeholder=\"minPts  (5)\"\n          onChange={handleOnChangeMinPts}\n          allowClear\n        />\n        <Input\n          placeholder=\"epsilon   (30)\"\n          onChange={handleOnChangeEpsilon}\n          allowClear\n        />\n        {clustersCount && (\n          <Alert\n            message={`Полученное количество кластеров: ${clustersCount - 1}`}\n            description={`Количество некластерированных точек (шумов): ${noisesCount}`}\n            type=\"info\"\n          />\n        )}\n        <div className=\"buttons\">\n          <Button onClick={handleRun} type=\"primary\">\n            Перезапуск\n          </Button>\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default DbscanComponent;\n","export function draw(context, data, labels, colors, extents, ranges) {\n  const { canvas } = context;\n\n  // Slightly clear the canvas to make new draws visible.\n  context.fillStyle = 'rgba(255,255,255, 1)';\n  context.fillRect(0, 0, canvas.width, canvas.height);\n\n  let point;\n  let i;\n\n  // Plot every point onto canvas.\n  for (i = 0; i < data.length; i++) {\n    context.save();\n\n    point = data[i];\n\n    // Make style fully opaque.\n    context.globalAlpha = 1;\n\n    // Move canvas origin on the grid to current point position.\n    context.translate(\n      (point[0] - extents[0].min + 1) * (canvas.width / (ranges[0] + 2)),\n      (point[1] - extents[1].min + 1) * (canvas.width / (ranges[1] + 2))\n    );\n\n    // context.translate(point[0], point[1]);\n\n    // context.translate(10, 10);\n\n    context.beginPath();\n\n    // Draw point circle.\n    context.arc(0, 0, 5, 0, Math.PI * 2, true);\n\n    const flag = labels[i];\n    if (flag === -1) {\n      context.strokeStyle = colors[labels[i]];\n      context.stroke();\n    } else {\n      context.fillStyle = colors[labels[i]];\n      context.shadowColor = colors[labels[i]];\n      context.shadowBlur = 20;\n      context.shadowOffsetX = 0;\n      context.shadowOffsetY = 0;\n      context.fill();\n    }\n\n    // Set the color for current point based on which cluster it belongs to.\n\n    // context.strokeStyle = 'black';\n\n    // Draw a stroke to make circle visible.\n\n    context.closePath();\n\n    context.restore();\n  }\n}\n","/* eslint-disable no-console */\nimport React, { useEffect, useLayoutEffect, useState } from 'react';\nimport { Tabs, Select, InputNumber, Button } from 'antd';\nimport KMeansComponent from './k-means';\n\nimport './index.css';\nimport DbscanComponent from './dbscan';\nimport { generateData, getOption } from './utils';\n\nconst { TabPane } = Tabs;\nconst { Option } = Select;\n\nconst Clustering = () => {\n  const [randomization, setRandomization] = useState('circular');\n  const [pointsCount, setPointsCount] = useState(1000);\n  const [isKmeansWorking, setIsKmeansWorking] = useState(true);\n\n  const maxX = 540;\n  const maxY = 540;\n  const offset = 0;\n\n  const [generatedData, setGeneratedData] = useState({ data: [] });\n\n  useLayoutEffect(() => {\n    const data = generateData(\n      pointsCount,\n      maxX,\n      maxY,\n      offset,\n      getOption(randomization)\n    );\n    setGeneratedData(data);\n    console.log('Сгенерированные данные', data);\n  }, [randomization]);\n\n  const onChangeRandomization = value => setRandomization(value);\n\n  const handleOnChangePointsCount = value => setPointsCount(value);\n\n  const recalcPoints = () => {\n    const data = generateData(\n      pointsCount,\n      maxX,\n      maxY,\n      offset,\n      getOption(randomization)\n    );\n    setGeneratedData(data);\n    console.log('Сгенерированные данные', data);\n  };\n\n  const operations = (\n    <div className=\"operations\">\n      <InputNumber\n        disabled={isKmeansWorking}\n        placeholder=\"Количество точек (1000)\"\n        onChange={handleOnChangePointsCount}\n        allowClear\n        style={{ width: 220 }}\n        min={10}\n        max={5000}\n      />\n      <Button icon=\"reload\" onClick={recalcPoints} loading={isKmeansWorking} />\n      <Select\n        style={{ width: 150 }}\n        placeholder=\"Выберите распределение\"\n        onChange={onChangeRandomization}\n        value={randomization}\n        disabled={isKmeansWorking}\n      >\n        <Option value=\"linear\">Линейное</Option>\n        <Option value=\"circular\">Круговое</Option>\n        <Option value=\"\">Равномерное</Option>\n      </Select>\n    </div>\n  );\n\n  return (\n    <div className=\"clustering-box\">\n      <Tabs defaultActiveKey=\"1\" tabBarExtraContent={operations}>\n        <TabPane tab=\"K-MEANS\" key=\"1\">\n          <KMeansComponent\n            data={generatedData.data}\n            maxX={maxX}\n            maxY={maxY}\n            isKmeansWorking={isKmeansWorking}\n            setIsKmeansWorking={setIsKmeansWorking}\n          />\n        </TabPane>\n        <TabPane tab=\"DBSCAN\" key=\"2\">\n          <DbscanComponent\n            data={generatedData.data}\n            ranges={generatedData.ranges}\n            extents={generatedData.extents}\n            maxX={maxX}\n            maxY={maxY}\n          />\n        </TabPane>\n      </Tabs>\n    </div>\n  );\n};\n\nexport default Clustering;\n","import React from 'react';\r\n// import RabbitAuth from './components/rabbit-auth';\r\n// import TestBox from './components/test-box';\r\nimport Clustering from './components/clustering';\r\n\r\nimport './App.css';\r\n\r\nconst App = () => {\r\n  return (\r\n    <div className=\"App\">\r\n      {/* <RabbitAuth /> */}\r\n      {/* <TestBox /> */}\r\n      {<Clustering />}\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default App;\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\n\r\nReactDOM.render(<App />, document.getElementById('root'));\r\n"],"sourceRoot":""}